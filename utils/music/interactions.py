# -*- coding: utf-8 -*-
from typing import List, Union, Optional

import disnake
from disnake.ext import commands

from utils.music.converters import time_format, fix_characters
from utils.others import check_cmd


class VolumeInteraction(disnake.ui.View):

    def __init__(self, inter):
        self.inter = inter
        self.volume = None
        super().__init__(timeout=30)
        self.process_buttons()

    def process_buttons(self):

        opts = []

        for l in [5, 20, 40, 60, 80, 100, 120, 150]:

            if l > 100:
                description = "Acima de 100% o audio pode ficar bem ruim."
            else:
                description = None
            opts.append(disnake.SelectOption(label=f"{l}%", value=f"vol_{l}", description=description))

        select = disnake.ui.Select(placeholder='N√≠vel:', options=opts)
        select.callback = self.callback
        self.add_item(select)

    async def callback(self, interaction: disnake.MessageInteraction):
        await interaction.response.edit_message(content=f"Volume alterado!",embed=None, view=None)
        self.volume = int(interaction.data.values[0][4:])
        self.stop()


class QueueInteraction(disnake.ui.View):

    def __init__(self, player, user: disnake.Member, timeout=60):

        self.player = player
        self.bot = player.bot
        self.user = user
        self.pages = []
        self.select_pages = []
        self.current = 0
        self.max_page = len(self.pages) - 1
        self.message: Optional[disnake.Message] = None
        super().__init__(timeout=timeout)
        self.embed = disnake.Embed(color=self.bot.get_color(user.guild.me))
        self.update_pages()
        self.update_embed()

    def update_pages(self):

        counter = 1

        entries = list(self.player.queue)

        self.pages = [entries[i:i + 12] for i in range(0, len(entries), 8)]
        self.select_pages.clear()

        self.clear_items()

        for n, page in enumerate(self.pages):

            txt = "\n"
            opts = []

            for t in page:

                duration = time_format(t.duration) if not t.is_stream else 'üî¥ Livestream'

                txt += f"`‚îå {counter})` [`{fix_characters(t.title, limit=50)}`]({t.uri})\n" \
                       f"`‚îî ‚è≤Ô∏è {duration}`" + (f" - `Repeti√ß√µes: {t.track_loops}`" if t.track_loops else  "") + \
                       f" **|** `‚úã` <@{t.requester}>\n"

                opts.append(
                    disnake.SelectOption(
                        label=t.author[:25], description=f"[{duration}] | {t.title}"[:50],
                        value=f"queue_select_{t.unique_id}",
                    )
                )

                counter += 1

            self.pages[n] = txt
            self.select_pages.append(opts)

        track_select = disnake.ui.Select(
            placeholder="Tocar uma m√∫sica espec√≠fica da p√°gina:",
            options=self.select_pages[self.current],
            custom_id="queue_track_selection",
            max_values=1
        )

        track_select.callback = self.track_select_callback

        self.add_item(track_select)

        first = disnake.ui.Button(emoji='‚èÆÔ∏è', style=disnake.ButtonStyle.grey)
        first.callback = self.first
        self.add_item(first)

        back = disnake.ui.Button(emoji='‚¨ÖÔ∏è', style=disnake.ButtonStyle.grey)
        back.callback = self.back
        self.add_item(back)

        next = disnake.ui.Button(emoji='‚û°Ô∏è', style=disnake.ButtonStyle.grey)
        next.callback = self.next
        self.add_item(next)

        last = disnake.ui.Button(emoji='‚è≠Ô∏è', style=disnake.ButtonStyle.grey)
        last.callback = self.last
        self.add_item(last)

        stop_interaction = disnake.ui.Button(emoji='‚èπÔ∏è', style=disnake.ButtonStyle.grey)
        stop_interaction.callback = self.stop_interaction
        self.add_item(stop_interaction)

        update_q = disnake.ui.Button(emoji='üîÑ', label="Refresh", style=disnake.ButtonStyle.grey)
        update_q.callback = self.update_q
        self.add_item(update_q)

        self.current = 0
        self.max_page = len(self.pages) - 1

    async def on_timeout(self) -> None:

        if not self.message:
            return

        embed = self.message.embeds[0]
        embed.set_footer(text="Tempo para interagir esgotado!")

        for c in self.children:
            c.disabled = True

        await self.message.edit(embed=embed, view=self)


    def update_embed(self):
        self.embed.title = f"**M√∫sicas da fila [{self.current+1} / {self.max_page+1}]**"
        self.embed.description = self.pages[self.current]
        self.children[2].options = self.select_pages[self.current]

        for n, c in enumerate(self.children):
            if isinstance(c, disnake.ui.StringSelect):
                self.children[n].options = self.select_pages[self.current]

    async def track_select_callback(self, interaction: disnake.MessageInteraction):

        track_id = interaction.values[0][13:]

        track = None

        for t in  self.player.queue:
            if t.unique_id == track_id:
                track = t
                break

        if not track:
            await interaction.send(f"M√∫sica com id \"{track_id}\" n√£o encontrada na fila do player...", ephemeral=True)
            return

        command = self.bot.get_slash_command("skip")

        interaction.music_bot = self.bot
        interaction.music_guild = self.user.guild

        try:
            await check_cmd(command, interaction)

            await command(interaction, query=f"{track.title} || ID > {track.unique_id}")
            self.update_pages()
            self.update_embed()
            await interaction.message.edit(embed=self.embed, view=self)
        except Exception as e:
            self.bot.dispatch('interaction_player_error', interaction, e)

    async def first(self, interaction: disnake.MessageInteraction):

        self.current = 0
        self.update_embed()
        await interaction.response.edit_message(embed=self.embed)

    async def back(self, interaction: disnake.MessageInteraction):

        if self.current == 0:
            self.current = self.max_page
        else:
            self.current -= 1
        self.update_embed()
        await interaction.response.edit_message(embed=self.embed, view=self)

    async def next(self, interaction: disnake.MessageInteraction):

        if self.current == self.max_page:
            self.current = 0
        else:
            self.current += 1
        self.update_embed()
        await interaction.response.edit_message(embed=self.embed, view=self)

    async def last(self, interaction: disnake.MessageInteraction):

        self.current = self.max_page
        self.update_embed()
        await interaction.response.edit_message(embed=self.embed)


    async def stop_interaction(self, interaction: disnake.MessageInteraction):

        await interaction.response.edit_message(content="Queue fechada", embed=None, view=None)
        self.stop()

    async def update_q(self, interaction: disnake.MessageInteraction):

        self.current = 0
        self.max_page = len(self.pages) - 1
        self.update_pages()
        self.update_embed()
        await interaction.response.edit_message(embed=self.embed, view=self)


class SelectInteraction(disnake.ui.View):

    def __init__(self, user: disnake.Member, opts: List[disnake.SelectOption], *, timeout=180):
        super().__init__(timeout=timeout)
        self.user = user
        self.selected = opts[0].value
        select_menu = disnake.ui.Select(placeholder='Selecione uma op√ß√£o:', options=opts)
        select_menu.callback = self.callback
        self.add_item(select_menu)
        self.inter = None

    async def interaction_check(self, interaction: disnake.MessageInteraction) -> bool:

        if interaction.user.id == self.user.id:
            return True

        await interaction.send(f"Apenas {self.user.mention} pode interagir aqui.", ephemeral = True)

    async def callback(self, interaction: disnake.MessageInteraction):
        self.selected = interaction.data.values[0]
        self.inter = interaction
        self.stop()


class AskView(disnake.ui.View):

    def __init__(self, *, ctx: Union[commands.Context, disnake.Interaction], timeout=None):
        super().__init__(timeout=timeout)
        self.selected = None
        self.ctx = ctx
        self.interaction_resp: Optional[disnake.MessageInteraction] = None

    async def interaction_check(self, interaction: disnake.MessageInteraction) -> bool:

        if interaction.user != self.ctx.author:
            await interaction.send("Voc√™ n√£o pode usar este bot√£o!", ephemeral=True)
            return False

        return True

    @disnake.ui.button(label="Sim", emoji="‚úÖ")
    async def allow(self, button, interaction: disnake.MessageInteraction):
        self.selected = True
        self.interaction_resp = interaction
        self.stop()

    @disnake.ui.button(label="N√£o", emoji="‚ùå")
    async def deny(self, button, interaction: disnake.MessageInteraction):
        self.selected = False
        self.interaction_resp = interaction
        self.stop()
